# TODO: Add comment
# 
# Author: n11176
###############################################################################
library("mise")
mise()
plot('x')
gc()
rm(list = ls())

#Estrutura de leitura lg_infln_bq	Peso


library(dplyr)
ajuste_lg_adjacentes<-function(x,incerteza,lg_fx,lg_fx2,fx1,fx2,fx3,red_min_1,red_min_2,red_min_3,TAPER=40, excluir_lg=c()){
  
  #cria o indice que sera usado para localizar as adjacentes
  x$id<-as.integer(seq.int(nrow(x)))
  
  #o loop tem que ser pela prioridade!!!	
  for (i in NROW(x):1){
    
    #acha o indice da prioridade em questao, começando pela última prioridade
    #A última prioridade cede largura para faixas mais prioritárias
    indice<-x[x[,5]==i,6]
    
    #garante que não é nem o primeiro e nem a última linha
    if(indice>1 & indice<NROW(x)){
      
      lg_min1 <-x[indice,2]
      lg_min2 <-x[indice+1,2]		
      lg_max0 <-x[indice-1,3]
      lg_max1 <-x[indice,3]
      
      #ao começar da última prioridade para a primeira, pode-se estreitar a faixa
      if(lg_max0>=lg_min1){lg_min1<-lg_max0+1}
      if(lg_min2<=lg_max1){lg_max1<-lg_min2-1}
      
      #O código abaixo foi comentado para que o loop do código principal possa limpar as faixas desnecessárias
      #com lg forçado, muitas vezes acontece a distorção da largura inf ficar maior que a superior
      #if(lg_min1>lg_max1){lg_min1<-lg_max1}
      
      x[indice,2]<-lg_min1
      x[indice,3]<-lg_max1
    }		
  }
  
  #otimiza larguras de placao para a faixa mais próxima de maior volume
  for (i in 2:(NROW(x)-1)){
    peso0 <-x[i-1,4]
    peso1 <-x[i,4]
    peso2 <-x[i+1,4]
    lg_min1 <-x[i,2]
    lg_max1 <-x[i,3]
    lg_placao0 <- x[i-1,1]
    lg_placao1 <- x[i,1]
    
    #ajusta a largura do placao para ficar mais próxima da adjacente de maior volume		
    #É melhor deixar o placao próximo da faixa anterior ou posterior
    lg_prx_sup <- x[i,2]+ifelse((x[i,2]+red_min_1+incerteza)<=lg_fx & (x[i,2]+fx1-incerteza)<=lg_fx,fx1,
                         ifelse((x[i,2]+red_min_2+incerteza)<=lg_fx2| (x[i,2]+fx2-incerteza)<=lg_fx2,fx2,fx3))-incerteza
    lg_prx_inf <- x[i,3]+ifelse((x[i,2]+red_min_1+incerteza)<=lg_fx & (x[i,2]+fx1-incerteza)<=lg_fx,red_min_1,
                         ifelse((x[i,2]+red_min_2+incerteza)<=lg_fx2| (x[i,2]+fx2-incerteza)<=lg_fx2,red_min_2,red_min_3))+incerteza
    
    
    #Não ajusta a largura do placao para larguras excessão
    if(!x[i,1] %in% excluir_lg){	
      if(peso2>peso1 & peso2>peso0 ){			
        if(lg_prx_sup<lg_prx_inf){lg_prx <-lg_prx_inf}else{lg_prx <-lg_prx_sup}
        x[i,1] <- lg_prx}
      
      #Para jogar a largura para baixo, o volume anterior tem que ser superior a 20% em relacao ao posterior	
      perce_peso <- (peso0-peso2)/(1-peso0)
      if(peso0>peso1 & peso0>peso2 & perce_peso>=0.2 ){
        x[i,1] <- lg_prx_inf}
      
      #Tentar colocar IL máximo entre laguras consecutivas de placão se possível
      if((lg_placao1-lg_placao0)>TAPER){
        lg_placao_temp<-lg_max1+ifelse((x[i,2]+red_min_1+incerteza)<=lg_fx & (x[i,2]+fx1-incerteza)<=lg_fx ,red_min_1,
                                ifelse((x[i,2]+red_min_2+incerteza)<=lg_fx2| (x[i,2]+fx2-incerteza)<=lg_fx2,red_min_2,red_min_3))+incerteza
        if((lg_placao_temp-lg_placao0)<=TAPER){
          x[i,1]<-lg_placao_temp
        }				
      }			
    }
  }	
  return(x)
}
aumentar_lg_media<-1 #busca também subir a largura média da placa.

#criacao do dataframe com os parâmetros que serão utilizados
arquivo <- c('UBC','UBC01','UBC02','BC','BC01','Q7','BS','TRIP','DEMAIS')
lg_tran_fx <- c(1490,1490,1490,1490,1490,1490,1490,1490,1490)
lg_tran_fx2 <- c(1580,1729,1490,1490,1580,1490,1490,1490,1490)
red_max_fx1 <- c(85,85,85,75,85,75,75,42,62) #(85-12=73) para LG<=lg_tran_fx
red_max_fx2 <- c(75,75,85,75,75,75,75,42,62) #(85-12=73) para lg_tran_fx <LG <=lg_tran_fx2
red_max_fx3 <- c(85,85,85,75,85,75,75,42,62) #(85-12=73) para lg_tran_fx2<LG
red_min_fx1 <- c(18,18,18,18,18,18,16,12,16) #(18-12=6) para LG<=lg_tran_fx
red_min_fx2 <- c(18,18,18,18,18,18,16,12,16) #(18-12=6) para lg_tran_fx <LG <=lg_tran_fx2
red_min_fx3 <- c(18,18,18,18,18,18,16,12,16) #(18-12=6) para lg_tran_fx2<LG
incerteza<-c(12,12,12,12,12,12,12,12,12)
tol_agrup<-c(1,1,1,1,1,1,1,1,1)
il<-c(40,40,40,40,40,40,40,40,40)
df_redmax<-data.frame(Arquivo=arquivo,Red_min_fx1 =red_min_fx1,Red_min_fx2 =red_min_fx2,Red_min_fx3 =red_min_fx3,
                      Red_max_fx1 =red_max_fx1,Red_max_fx2 =red_max_fx2,Red_max_fx3 =red_max_fx3,
                      Incerteza=incerteza,Tol_agrup=tol_agrup,Lg_tran=lg_tran_fx,Lg_tran2=lg_tran_fx2,IL=il)

#Essa verificação é para debug, evitando entrar no loop para checar os valores
if(length(arquivo)==1){ifile<-arquivo}

#chave final desse for está no final do script
for (ifile in arquivo){ 
  print(ifile)
  
  dir <-'d:/Agrupamento LG/'
  extensao <-'.txt'
  BD = paste0(dir,'geral',extensao) 
  tabela_lg <- read.table(file = BD, header = TRUE, sep='\t',dec = ".", stringsAsFactors = FALSE)
  tabela_lg<-tabela_lg[tabela_lg$GrupoSGF==ifile,c('lg_infln_bq','Peso')]
  
  lg_ped_min <- as.numeric(749+seq(1:(1881-750)))
  peso_inicial <- as.numeric(rep_len(1, 1881-750))
  dataframe_inicial <- data.frame(lg_ped_min,peso_inicial)
  tabela_lg<- left_join(dataframe_inicial, tabela_lg, by = c("lg_ped_min" = "lg_infln_bq"))
  tabela_lg[,2]<-tabela_lg[,2]+ifelse(is.na(tabela_lg[,3]), 0, tabela_lg[,3])
  tabela_lg[,3]<-NULL
  
  #larg_prior <-c(1050,1250,1550,1840)
  IL<-df_redmax[df_redmax$Arquivo==ifile,'IL']
  tol_agrup_lg<-df_redmax[df_redmax$Arquivo==ifile,'Tol_agrup']
  incerteza <-df_redmax[df_redmax$Arquivo==ifile,'Incerteza']
  
  fx1 <-df_redmax[df_redmax$Arquivo==ifile,'Red_max_fx1']-incerteza#(85-12=73)
  fx2 <-df_redmax[df_redmax$Arquivo==ifile,'Red_max_fx2']-incerteza#(85-12=73)
  fx3 <-df_redmax[df_redmax$Arquivo==ifile,'Red_max_fx3']-incerteza#(85-12=73)
  red_min_1 <-df_redmax[df_redmax$Arquivo==ifile,'Red_min_fx1']-incerteza #(18-incerteza=6)
  red_min_2 <-df_redmax[df_redmax$Arquivo==ifile,'Red_min_fx2']-incerteza #(18-incerteza=6)
  red_min_3 <-df_redmax[df_redmax$Arquivo==ifile,'Red_min_fx3']-incerteza #(18-incerteza=6)
  
  lg_fx <-df_redmax[df_redmax$Arquivo==ifile,'Lg_tran'] #largura de transição para critérios diferentes
  lg_fx2 <-df_redmax[df_redmax$Arquivo==ifile,'Lg_tran2'] #largura de transição para critérios diferentes
  tabela_lg$idfx<-ifelse((tabela_lg[,1]+red_min_1+incerteza)<=lg_fx & (tabela_lg[,1]+fx1-incerteza)<=lg_fx,1,
                  ifelse((tabela_lg[,1]+red_min_2+incerteza)<=lg_fx2 | (tabela_lg[,1]+fx2-incerteza)<=lg_fx2,2,3))#coluna temporária
  
  tabela_lg$lg_placao <- tabela_lg[,1]+ifelse(tabela_lg$idfx==1,fx1,ifelse(tabela_lg$idfx==2,fx2,fx3)) #Ajuste para tranformar a faixa de pedido de BQ para placao
  tabela_lg$lg_ped_max <- tabela_lg$lg_placao-ifelse(tabela_lg$idfx==1,red_min_1,ifelse(tabela_lg$idfx==2,red_min_2,red_min_3))-incerteza
  tabela_lg[,2]<-tabela_lg[,2]*(1+aumentar_lg_media*tabela_lg[,3]) #tabela_lg[,2]=Qtde de placao * #tabela_lg[,3]=Largura do placao, seria quase uma unidade de peso
  tabela_lg$peso_acumulado_max<-0
  tabela_lg$peso_original<-tabela_lg[,2]
  tabela_lg$peso_acum_proc<-0
  tabela_lg$id<-as.numeric(seq.int(nrow(tabela_lg)))
  tabela_lg$idfx<-NULL
  
  for (l in 1:NROW(tabela_lg)){
    #acumula o peso das faixas de pedidos na linha da largura de cada placao 
    #É importante esse loop ficar dentro do outro loop, só assim calcula o peso e desconsidera volumes já considerados
    for (i in 1:NROW(tabela_lg)){
      tabela_lg[i,5] <- sum(tabela_lg[tabela_lg[,1]>=tabela_lg[i,1] & tabela_lg[,1]<=tabela_lg[i,4],2])}
    
    #Força uso de larguras específicas
    peso_acumulado_max <- max(tabela_lg[,5],na.rm=TRUE)
    if(exists("larg_prior")){
      if(tabela_lg[l,3] %in% larg_prior){
        peso_acumulado_max<-99999999
        tabela_lg[l,5]<-peso_acumulado_max}}
    #Em caso de pesos máximos iguais, pega maior seq
    seq_max <- max(tabela_lg[tabela_lg[5]==peso_acumulado_max,8],na.rm=TRUE) 
    
    #pega a maior e menor largura de pedido para o maior peso acumulado
    lg_min_pedido_temp <- tabela_lg[tabela_lg[,5]==peso_acumulado_max & tabela_lg[,8]==seq_max,1,drop=FALSE]
    lg_max_pedido_temp <- tabela_lg[tabela_lg[,5]==peso_acumulado_max & tabela_lg[,8]==seq_max,4,drop=FALSE]
    
    #limpa o peso de faixas já usadas
    tabela_lg[,2][tabela_lg[,1]>=lg_min_pedido_temp[1,1] & tabela_lg[,1]<=lg_max_pedido_temp[1,1] ]<- 0 
    
    #coloca o peso acumulado de faixas já dela
    tabela_lg[,7][tabela_lg[,4]==lg_max_pedido_temp[1,1]]<- peso_acumulado_max 
  }
  
  #Mudando as posicoes das colunas e deixando de selecionar as não importantes
  tabela_lg<-tabela_lg[,c(3,1,4,7,6)] 
  
  #filtra somente faixas úteis
  tabela_temp <-tabela_lg
  tabela_lg<-tabela_lg[tabela_lg[,4]>0,]#filtra somente peso acumulado processado>0, faixas otimizadas
  tabela_lg[,5]<-NULL #apaga peso original por nao fazer sentido para otimizada
  
  #cria uma coluna para indicar a priorização das larguras mais importantes por volume associado
  tabela_lg<-tabela_lg[order(-tabela_lg[,4],-tabela_lg[,1],tabela_lg[,2]),] 
  tabela_lg$prioridade <- seq.int(nrow(tabela_lg))
  tabela_lg<-tabela_lg[order(tabela_lg[,1],tabela_lg[,2]),]
  
  #otimiza faixas redundantes ou absurdas
  # dentro da função ajuste_lg_adjacentes foi comentado um código para que esse loop do código principal possa limpar as faixas redundantes ou absurdas
  for (idloop in 1:30){
    #Ajusta intersecção de faixas e deixa a lg placao mais próxima do maior volume
    if(!exists("larg_prior")){larg_prior<-c()}
    tabela_lg<-ajuste_lg_adjacentes(tabela_lg,incerteza,lg_fx,lg_fx2,fx1,fx2,fx3,red_min_1,red_min_2,red_min_3,TAPER=IL,larg_prior)
    
    #Recalculado do peso acumulado por faixa
    tabela_lg[,4] <-0
    for (i in 1:NROW(tabela_lg)){
      tabela_lg[i,4] <- sum(tabela_temp[tabela_temp[,3]>=tabela_lg[i,2] & tabela_temp[,3]<=tabela_lg[i,3],5])}
    
    #excluindo faixa de peso zero
    tabela_lg<-tabela_lg[tabela_lg[,4]>0,]
    
    #cria uma coluna para indicar a priorização das larguras mais importantes por volume associado
    tabela_lg<-tabela_lg[order(-tabela_lg[,4],-tabela_lg[,1]),] 
    tabela_lg$prioridade <- seq.int(nrow(tabela_lg))
    tabela_lg<-tabela_lg[order(tabela_lg[,1],tabela_lg[,2]),]
  }
  
  #parte que otimiza as faixas que possuem pequenas diferenças (tol_agrup_lg)
  for (j in 2:NROW(tabela_lg)){
    if((tabela_lg[j,2]-tabela_lg[j-1,2])<=tol_agrup_lg){
      tabela_lg[j,2]<-tabela_lg[j-1,2]
      tabela_lg[j,4]<-tabela_lg[j,4]+tabela_lg[j-1,4]
      tabela_lg[j-1,]<-NA}
  }
  tabela_lg<-tabela_lg[complete.cases(tabela_lg),]
  
  #Criando campos dos delta minimo e máximo entre lg de placao e pedido
  tabela_lg$lg_placao_pedido_max <-(tabela_lg[,1]-tabela_lg[,2])
  tabela_lg$lg_placao_pedido_min <-(tabela_lg[,1]-tabela_lg[,3])
  
  #Salva o arquivo para leitura
  write.table(tabela_lg, file=paste0(dir,'otimizado_',ifile,'.csv'),row.names=FALSE,sep=";",dec = ".")
  
}# chave do loop do arquivo
 

#ajustar para o preenchimento do padrao---------------------------------
arquivo <- c('UBC','UBC01','UBC02','BC','BC01','Q7','BS','TRIP','DEMAIS')
ubc<-c('19','20')
ubc01<-c('01')
ubc02<-c('02')
bc<-c('09','10','03','06','27','17','18','30','34')
bc01<-c('03')
q7<-c('31')
bs<-c('41','07','29','14','33','13')
trip<-c('38','43')
demais<-c('00')
list_padrao<-list(UBC=ubc,UBC01=ubc01,UBC02=ubc02,BC=bc,BC01=bc01,Q7=q7,BS=bs,TRIP=trip,DEMAIS=demais)

for (ifile in arquivo){ 
  tabela_lg <- read.table(file=paste0('d:/Agrupamento LG/otimizado_',ifile,'.csv'), header = TRUE, sep=';',dec = ".", stringsAsFactors = FALSE)
  for (sgf in list_padrao[[ifile]]){
    tabela_lg_temp<-tabela_lg
    tabela_lg_temp$sgf_ini<-sgf
    tabela_lg_temp$sgf_fim<-sgf
    tabela_lg_temp$esppl_ini<-220
    tabela_lg_temp$esppl_fim<-230
    tabela_lg_temp$aco<-ifile
    if(!exists("tabela_lgfinal")){
      tabela_lgfinal<-tabela_lg_temp
    }else{
      tabela_lgfinal<-rbind(tabela_lgfinal,tabela_lg_temp)}
  }
  write.table(tabela_lgfinal, file=paste0(dir,'otimizado_processado',ifile,'.csv'),row.names=FALSE,sep=";",dec = ".")
    if(!exists("processado_geral")){
      processado_geral<-tabela_lgfinal
    }else{
      processado_geral<-rbind(processado_geral,tabela_lgfinal)}
  rm(tabela_lgfinal)
}
write.table(processado_geral, file=paste0(dir,'otimizado_processado_geral.csv'),row.names=FALSE,sep=";",dec = ".")
rm(processado_geral)
